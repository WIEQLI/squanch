

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Quantum Teleportation &mdash; SQUANCH 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Superdense Coding" href="superdense-coding.html" />
    <link rel="prev" title="Demonstrations" href="../demos.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> SQUANCH
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../demos.html">Demonstrations</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Quantum Teleportation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#protocol">Protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#source-code">Source code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="superdense-coding.html">Superdense Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="man-in-the-middle.html">Man-In-The-Middle Attack</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">SQUANCH API reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SQUANCH</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../demos.html">Demonstrations</a> &raquo;</li>
        
      <li>Quantum Teleportation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/demos/quantum-teleportation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="quantum-teleportation">
<span id="teleportationdemo"></span><h1>Quantum Teleportation<a class="headerlink" href="#quantum-teleportation" title="Permalink to this headline">¶</a></h1>
<p>Quantum teleportation allows two parties that share an entangled pair to transfer a quantum state using classical communication. This process has tremendous applicability to quantum networks, transferring fragile quantum states between distant nodes. Conecptually, quantum teleportation is the inverse of <a class="reference internal" href="superdense-coding.html#superdensecodingdemo"><span class="std std-ref">superdense coding</span></a>.</p>
<p>The source code for this demo is included in the <cite>demos</cite> directory of the SQUANCH repository.</p>
<div class="section" id="protocol">
<h2>Protocol<a class="headerlink" href="#protocol" title="Permalink to this headline">¶</a></h2>
<img alt="https://www.media.mit.edu/quanta/qasm2circ/test2.png" src="https://www.media.mit.edu/quanta/qasm2circ/test2.png" />
<p>Below is a simple two-party quantum teleportation protocol. We’ll be using the above circuit diagram.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Alice generates an EPR pair; for this protocol, we’ll use the state <span class="math notranslate">\(\lvert q_1 q_2 \rangle = \frac{1}{\sqrt{2}} \left (\lvert 00 \rangle + \lvert 11 \rangle \right )\)</span>. She will keep one particle in the pair and send the other one to Bob.</li>
<li>Alice entangles her qubit <span class="math notranslate">\(q_0\)</span> with her ancilla <span class="math notranslate">\(q_1\)</span> by applying controlled-not and Hadamard operators.</li>
<li>Alice measures both of her qubits and communicates the results (two bits) to Bob through a classical channel. Bob’s qubit is now in one of four possible states, one of which is <span class="math notranslate">\(\lvert q_0 \rangle\)</span>. Bob will use Alice’s two bits to determine what operations to apply to recover <span class="math notranslate">\(\lvert q_0 \rangle\)</span>.</li>
<li>Bob applies a Pauli-X operator to his qubit if Alice’s ancilla collapsed to <span class="math notranslate">\(\lvert q_1 \rangle = \lvert 1 \rangle\)</span>, and he applies a Pauli-Z operator to his qubit if her qubit collapsed to <span class="math notranslate">\(\lvert q_0 \rangle = \lvert 1 \rangle\)</span>.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Quantum teleportation is a simple protocol to implement in any quantum computing simulation framework, but SQUANCH’s <a class="reference internal" href="../api/agent.html#agent"><span class="std std-ref">Agent</span></a> and <a class="reference internal" href="../api/channels.html#channels"><span class="std std-ref">Channel</span></a> modules provide an intuitive way to work with sending and receiving qubits, and the <a class="reference internal" href="../api/qstream.html#qstream"><span class="std std-ref">QStream</span></a> module allows you to create performant simulations of teleporting a large number of states in succession.</p>
<p>First, let’s import what we’ll need.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">squanch</span> <span class="k">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Now, we’ll want to define the behavior of Alice and Bob. We’ll extend the <a class="reference internal" href="../api/agent.html#agent"><span class="std std-ref">Agent</span></a> class to create two child classes, and then we can change the <cite>run()</cite> method for each of them. For Alice, we’ll want to include logic for creating an EPR pair and sending it to Bob, as well as the subsequent entanglement and measurement logic.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Alice</span><span class="p">(</span><span class="n">Agent</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Alice sends qubits to Bob using a shared Bell pair&#39;&#39;&#39;</span>

        <span class="k">def</span> <span class="nf">distribute_bell_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="c1"># Create a Bell pair and send one particle to Bob</span>
                <span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">CNOT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qsend</span><span class="p">(</span><span class="n">bob</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">teleport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
                <span class="c1"># Perform the teleportation</span>
                <span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="n">H</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                <span class="c1"># Tell Bob whether to apply Pauli-X and -Z over classical channel</span>
                <span class="n">bob_should_apply_x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span> <span class="c1"># if Bob should apply X</span>
                <span class="n">bob_should_apply_z</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span> <span class="c1"># if Bob should apply Z</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">csend</span><span class="p">(</span><span class="n">bob</span><span class="p">,</span> <span class="p">[</span><span class="n">bob_should_apply_x</span><span class="p">,</span> <span class="n">bob_should_apply_z</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">qsystem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">:</span>
                        <span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qsystem</span><span class="o">.</span><span class="n">qubits</span> <span class="c1"># q is state to teleport, a and b are Bell pair</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">distribute_bell_pair</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">teleport</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that you can add arbitrary methods, such as <cite>distribute_bellPair()</cite> and <cite>teleport()</cite>, to agent child classes; just be careful not to overwrite any existing class methods other than <cite>run()</cite>.</p>
<p>For Bob, we’ll want to include the logic to receive the particle from Alice and act on it according to Alice’s measurement results.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bob</span><span class="p">(</span><span class="n">Agent</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Bob receives qubits from Alice and measures the results&#39;&#39;&#39;</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">measurement_results</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">:</span>
                        <span class="c1"># Bob receives a qubit from Alice</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qrecv</span><span class="p">(</span><span class="n">alice</span><span class="p">)</span>
                        <span class="c1"># Bob receives classical instructions from alice</span>
                        <span class="n">should_apply_x</span><span class="p">,</span> <span class="n">should_apply_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crecv</span><span class="p">(</span><span class="n">alice</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">should_apply_x</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">should_apply_z</span><span class="p">:</span> <span class="n">Z</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="c1"># Measure the output state</span>
                        <span class="n">measurement_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">measure</span><span class="p">())</span>
                <span class="c1"># Put results in output object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">measurement_results</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we want to prepare a set of states for Alice to teleport to Bob. Since each trial requires a set of three qubits, we’ll allocate space for a <span class="math notranslate">\(3 \times 10\)</span> <cite>QStream</cite>. We’ll also create a shared output dictionary to allow agents to communicate between processes. Explicitly allocating and passing memory to agents is necessary because each agent spawns and runs in a separate process, which (generally) have separate memory pools. (See <a class="reference internal" href="../api/agent.html#agent"><span class="std std-ref">Agent</span></a> API for more details.)</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Allocate memory and output structures</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">Agent</span><span class="o">.</span><span class="n">shared_hilbert_space</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># 3 qubits per trial, 10 trials</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">Agent</span><span class="o">.</span><span class="n">shared_output</span><span class="p">()</span>

<span class="c1"># Prepare the initial states</span>
<span class="n">stream</span> <span class="o">=</span> <span class="n">QStream</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="n">states_to_teleport</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">qsystem</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">states_to_teleport</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">qsystem</span><span class="o">.</span><span class="n">qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># flip the qubits corresponding to 1 states</span>
</pre></div>
</div>
<p>For agents to communicate with each other, they must be connected via quantum or classical channels. The <cite>Agent.qconnect</cite> and <cite>Agent.cconnect</cite> methods add a bidirectional quantum or classical channel, repsectively, to two agent instances and take a channel model and kwargs as optional arguments. In this example, we won’t worry about a channel model and will just use the default QChannel and CChannel options. Let’s create instances for Alice and Bob and connect them appropriately</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make and connect the agents</span>
<span class="n">alice</span> <span class="o">=</span> <span class="n">Alice</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
<span class="n">alice</span><span class="o">.</span><span class="n">qconnect</span><span class="p">(</span><span class="n">bob</span><span class="p">)</span> <span class="c1"># add a quantum channel</span>
<span class="n">alice</span><span class="o">.</span><span class="n">cconnect</span><span class="p">(</span><span class="n">bob</span><span class="p">)</span> <span class="c1"># add a classical channel</span>
</pre></div>
</div>
<p>Finally, we call <cite>agent.start()</cite> for each agent to signal the process to start running, and <cite>agent.join()</cite> to wait for all agents to finish before proceeding in the program.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run everything</span>
<span class="n">alice</span><span class="o">.</span><span class="n">start</span><span class="p">();</span> <span class="n">bob</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">alice</span><span class="o">.</span><span class="n">join</span><span class="p">();</span> <span class="n">bob</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Teleported states </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">states_to_teleport</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received states   </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s2">&quot;Bob&quot;</span><span class="p">]))</span>
</pre></div>
</div>
<p>Running what we have so far produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Teleported</span> <span class="n">states</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">Received</span> <span class="n">states</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>So at least for the simple cases, our implementation seems to be working! Let’s do a little more complex test case now.</p>
<p>We’ll now try teleporting an ensemble of identical states <span class="math notranslate">\(R_{X}(\theta) \lvert 0 \rangle\)</span> for several values of <span class="math notranslate">\(\theta\)</span>. We’ll then measure each teleported state and see how it compares with the expected outcome.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>  <span class="c1"># RX angles to apply</span>
<span class="n">num_trials</span> <span class="o">=</span> <span class="mi">250</span>  <span class="c1"># number of trials for each angle</span>

<span class="c1"># Allocate memory and output structures</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">Agent</span><span class="o">.</span><span class="n">shared_hilbert_space</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_trials</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">Agent</span><span class="o">.</span><span class="n">shared_output</span><span class="p">()</span>

<span class="c1"># Prepare the initial states in the stream</span>
<span class="n">stream</span> <span class="o">=</span> <span class="n">QStream</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>
<span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_trials</span><span class="p">):</span>
                <span class="n">q</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">.</span><span class="n">qubits</span>
                <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

<span class="c1"># Make the agents and connect with quantum and classical channels</span>
<span class="n">alice</span> <span class="o">=</span> <span class="n">Alice</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
<span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
<span class="n">alice</span><span class="o">.</span><span class="n">qconnect</span><span class="p">(</span><span class="n">bob</span><span class="p">)</span>
<span class="n">alice</span><span class="o">.</span><span class="n">cconnect</span><span class="p">(</span><span class="n">bob</span><span class="p">)</span>

<span class="c1"># Run the simulation</span>
<span class="n">Simulation</span><span class="p">(</span><span class="n">alice</span><span class="p">,</span> <span class="n">bob</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1"># Plot the results</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s2">&quot;Bob&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">num_trials</span><span class="p">))</span>
<span class="n">observed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">observed</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Observed&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Expected&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$\Theta$ in $R_X(\Theta)$ applied to qubits&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fractional $\left | 1 </span><span class="se">\\</span><span class="s2">right &gt;$ population&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This gives us the following pretty plot.</p>
<img alt="../_images/teleportationRotation.png" src="../_images/teleportationRotation.png" />
</div>
<div class="section" id="source-code">
<h2>Source code<a class="headerlink" href="#source-code" title="Permalink to this headline">¶</a></h2>
<p>The full source code for this demonstration is available in the demos directory of the SQUANCH repository.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="superdense-coding.html" class="btn btn-neutral float-right" title="Superdense Coding" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../demos.html" class="btn btn-neutral" title="Demonstrations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, AT&amp;T.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>